#!/usr/bin/env node

/**
 * Live Testing Launcher - All-in-One Testing Experience
 *
 * This script manages both the development server and test status server,
 * providing a seamless way to access the complete testing dashboard.
 *
 * Features:
 * - Auto-starts dev server if needed
 * - Auto-starts test status server for real-time unit test results
 * - Opens live testing dashboard in browser
 * - Graceful shutdown on Ctrl+C
 * - Unified logging for both services
 */

const { spawn } = require('child_process');
const http = require('http');
const fs = require('fs');
const path = require('path');

// Configuration
const DEV_SERVER_PORT = 8080; // Changed from 8081 to 8080 (vite default)
const DEV_SERVER_HOST = 'localhost';
const TEST_STATUS_PORT = 3001;
const LIVE_TESTING_PATH = '/live-testing.html';
const PACKAGE_JSON_PATH = path.join(__dirname, '../package.json');

// Colors for terminal output
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

function checkServerRunning(host, port) {
    return new Promise((resolve) => {
        const options = {
            hostname: host,
            port: port,
            path: '/',
            method: 'GET',
            timeout: 2000
        };

        const req = http.request(options, (res) => {
            resolve(res.statusCode === 200);
        });

        req.on('error', () => resolve(false));
        req.on('timeout', () => {
            req.destroy();
            resolve(false);
        });

        req.end();
    });
}

function checkTestStatusServer() {
    return new Promise((resolve) => {
        const options = {
            hostname: 'localhost',
            port: TEST_STATUS_PORT,
            path: '/test-status',
            method: 'GET',
            timeout: 2000
        };

        const req = http.request(options, (res) => {
            resolve(res.statusCode === 200);
        });

        req.on('error', () => resolve(false));
        req.on('timeout', () => {
            req.destroy();
            resolve(false);
        });

        req.end();
    });
}


function startDevServer() {
    return new Promise((resolve, reject) => {
        log('ğŸŒ Starting development server...', 'cyan');

        const devServer = spawn('npm', ['run', 'dev'], {
            stdio: ['pipe', 'pipe', 'pipe'],
            cwd: path.dirname(PACKAGE_JSON_PATH)
        });

        let serverReady = false;

        devServer.stdout.on('data', (data) => {
            const output = data.toString();

            // Look for Vite's ready message
            if (output.includes('Local:') || output.includes('ready in')) {
                serverReady = true;
                log('âœ… Development server started successfully!', 'green');
                resolve(devServer);
            }
        });

        devServer.stderr.on('data', (data) => {
            process.stderr.write(data);
        });

        devServer.on('error', (error) => {
            log(`âŒ Failed to start dev server: ${error.message}`, 'red');
            reject(error);
        });

        // Fallback timeout
        setTimeout(() => {
            if (!serverReady) {
                log('âš ï¸  Dev server may still be starting...', 'yellow');
                resolve(devServer);
            }
        }, 5000);
    });
}

function startTestStatusServer() {
    return new Promise((resolve, reject) => {
        log('ğŸ§ª Starting test status server...', 'magenta');

        const testServer = spawn('node', ['scripts/test-status-server.js'], {
            stdio: ['pipe', 'pipe', 'pipe'],
            cwd: path.dirname(PACKAGE_JSON_PATH)
        });

        let serverReady = false;

        testServer.stdout.on('data', (data) => {
            const output = data.toString();
            process.stdout.write(data);

            // Look for server ready message
            if (output.includes('Test Status Server running')) {
                serverReady = true;
                log('âœ… Test status server started successfully!', 'green');
                resolve(testServer);
            }
        });

        testServer.stderr.on('data', (data) => {
            process.stderr.write(data);
        });

        testServer.on('error', (error) => {
            log(`âŒ Failed to start test status server: ${error.message}`, 'red');
            reject(error);
        });

        // Fallback timeout
        setTimeout(() => {
            if (!serverReady) {
                log('âš ï¸  Test status server may still be starting...', 'yellow');
                resolve(testServer);
            }
        }, 3000);
    });
}


function openBrowser(url) {
    const start = process.platform === 'darwin' ? 'open' :
                  process.platform === 'win32' ? 'start' : 'xdg-open';

    spawn(start, [url], { stdio: 'ignore' });
}

// Track running processes for cleanup
let devServerProcess = null;
let testServerProcess = null;

// Graceful shutdown handler
function handleShutdown() {
    log('\nğŸ›‘ Shutting down servers...', 'yellow');

    let shutdownPromises = [];

    if (testServerProcess) {
        log('   ğŸ§ª Stopping test status server...', 'magenta');
        testServerProcess.kill();
        shutdownPromises.push(
            new Promise(resolve => {
                testServerProcess.on('exit', resolve);
                setTimeout(resolve, 2000); // Force resolve after 2 seconds
            })
        );
    }

    if (devServerProcess) {
        log('   ğŸŒ Stopping development server...', 'cyan');
        devServerProcess.kill();
        shutdownPromises.push(
            new Promise(resolve => {
                devServerProcess.on('exit', resolve);
                setTimeout(resolve, 2000); // Force resolve after 2 seconds
            })
        );
    }

    Promise.all(shutdownPromises).then(() => {
        log('âœ… All servers stopped gracefully', 'green');
        process.exit(0);
    });
}

async function main() {
    log('ğŸ§  Live Testing Launcher - All-in-One Testing Experience', 'bright');
    log('===============================================', 'cyan');

    // Set up graceful shutdown
    process.on('SIGINT', handleShutdown);
    process.on('SIGTERM', handleShutdown);

    try {
        // Check which servers are already running
        const isDevServerRunning = await checkServerRunning(DEV_SERVER_HOST, DEV_SERVER_PORT);
        const isTestServerRunning = await checkTestStatusServer();

        // Start servers that aren't running
        if (!isDevServerRunning) {
            devServerProcess = await startDevServer();
        } else {
            log('âœ… Development server is already running!', 'green');
        }

        if (!isTestServerRunning) {
            testServerProcess = await startTestStatusServer();
        } else {
            log('âœ… Test status server is already running!', 'green');
        }

        // Give servers a moment to fully start
        await new Promise(resolve => setTimeout(resolve, 2000));

        const liveTestingUrl = `http://${DEV_SERVER_HOST}:${DEV_SERVER_PORT}${LIVE_TESTING_PATH}`;

        log(`ğŸŒ Opening Live Testing Dashboard...`, 'cyan');
        log(`   URL: ${liveTestingUrl}`, 'blue');

        openBrowser(liveTestingUrl);

        log('', 'reset');
        log('ğŸ¯ Complete Testing Dashboard Features:', 'bright');
        log('   â€¢ ğŸ“Š Real-time memory metrics monitoring', 'green');
        log('   â€¢ ğŸ§ª Unit test status with live refresh', 'green');
        log('   â€¢ ğŸ”¬ Vitest UI instructions for interactive testing', 'green');
        log('   â€¢ ğŸ§© EventBus memory leak validation', 'green');
        log('   â€¢ ğŸ® Scene transition memory testing', 'green');
        log('   â€¢ ğŸ”„ Object lifecycle verification', 'green');
        log('   â€¢ ğŸ’¾ Interactive memory pressure testing', 'green');
        log('', 'reset');

        // Show server status
        const serverStatus = [];
        if (isDevServerRunning) serverStatus.push('âœ… Dev Server');
        if (isTestServerRunning) serverStatus.push('âœ… Test Status Server');
        if (!isDevServerRunning) serverStatus.push('ğŸš€ Dev Server');
        if (!isTestServerRunning) serverStatus.push('ğŸš€ Test Status Server');

        log(`ğŸ“¡ Active Services: ${serverStatus.join(', ')}`, 'blue');
        log('', 'reset');

        if (devServerProcess || testServerProcess) {
            log('ğŸ’¡ Tip: Press Ctrl+C to gracefully shut down all servers', 'yellow');
            log('   Both servers will be stopped automatically', 'yellow');
            log('', 'reset');

            // Keep the script running to maintain servers
            setInterval(() => {}, 1000);
        } else {
            log('ğŸ‰ Live Testing Dashboard opened in your browser!', 'green');
            log('   All servers were already running independently.', 'blue');
            log('', 'reset');
            log('ğŸ’¡ You can stop individual servers as needed', 'yellow');
            process.exit(0);
        }

    } catch (error) {
        log(`âŒ Error: ${error.message}`, 'red');

        // Cleanup any started processes
        if (devServerProcess) devServerProcess.kill();
        if (testServerProcess) testServerProcess.kill();

        process.exit(1);
    }
}

// Handle uncaught promise rejections
process.on('unhandledRejection', (reason, promise) => {
    log(`âŒ Unhandled Rejection: ${reason}`, 'red');
    process.exit(1);
});

// Run the main function
main();