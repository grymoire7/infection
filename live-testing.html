<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Testing</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .container {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .success {
            color: #4caf50;
            border-left: 4px solid #4caf50;
            padding-left: 10px;
            margin: 10px 0;
        }

        .warning {
            color: #ff9800;
            border-left: 4px solid #ff9800;
            padding-left: 10px;
            margin: 10px 0;
        }

        .error {
            color: #f44336;
            border-left: 4px solid #f44336;
            padding-left: 10px;
            margin: 10px 0;
        }

        button {
            background: #4caf50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #45a049;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4caf50;
        }

        .log {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
        }

        .improvement {
            background: #2e7d32;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }

        .improvement h3 {
            margin-top: 0;
            color: #81c784;
        }
    </style>
</head>
<body>
    <h1>üß† Live Memory & Event Listener Testing</h1>
    <p>Interactive testing dashboard for memory management validation, event cleanup verification, and performance monitoring.</p>

    <!-- Embedded Game -->
    <div class="container" style="background: #1a1a1a; padding: 10px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; color: #2196f3;">üéÆ Game View</h3>
            <button onclick="toggleGameView()" id="toggle-game-btn" style="background: #2196f3; padding: 5px 15px;">Show Game</button>
        </div>
        <div id="game-iframe-container" style="display: none; border: 2px solid #444; border-radius: 4px; overflow: hidden;">
            <iframe id="game-frame" src="/" style="width: 100%; height: 600px; border: none; display: block;"></iframe>
        </div>
    </div>

    <div class="container" style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid #2196f3;">
        <h3 style="margin-top: 0; color: #2196f3;">üìñ How to Use This Dashboard</h3>

        <div id="connection-status" style="padding: 10px; margin: 10px 0; border-radius: 4px; background: rgba(255, 152, 0, 0.2); border-left: 4px solid #ff9800;">
            <div style="font-weight: bold; color: #ff9800;">‚ö†Ô∏è Game not detected</div>
            <div style="font-size: 0.85em; margin-top: 5px;">Click "Show Game" above to load the game in this page.</div>
        </div>

        <div style="font-size: 0.9em; line-height: 1.6;">
            <strong>Quick Setup (2 clicks!):</strong>
            <ol style="margin: 10px 0;">
                <li>Click the <strong style="color: #2196f3;">"Show Game"</strong> button above to load the game in this page</li>
                <li>Wait ~5 seconds for the connection status to turn green</li>
                <li>Start testing! üéâ</li>
            </ol>

            <div style="margin: 10px 0; padding: 10px; background: rgba(76, 175, 80, 0.15); border-radius: 4px;">
                <div style="font-weight: bold; color: #4caf50; margin-bottom: 5px;">‚úÖ Why embed the game?</div>
                <div style="font-size: 0.85em; color: #666;">
                    The game needs to be in the same page as the dashboard so the testing tools can access it.
                    Click "Show Game" and the game will load in an iframe above. You can hide it anytime by clicking again.
                </div>
            </div>

            <details style="margin-top: 15px;">
                <summary style="cursor: pointer; font-weight: bold; color: #888;">üìñ Alternative: Use npm run test:live (opens this page automatically)</summary>
                <div style="margin-top: 10px; padding-left: 15px;">
                    <div style="font-size: 0.9em;">Run this command in your terminal:</div>
                    <pre style="background: #1a1a1a; padding: 10px; border-radius: 4px; margin: 5px 0; overflow-x: auto;"><code>npm run test:live</code></pre>
                    <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        This automatically starts servers and opens this dashboard. Then click "Show Game" to begin testing.
                    </div>
                </div>
            </details>

            <div style="margin-top: 15px; padding: 8px; background: rgba(76, 175, 80, 0.2); border-radius: 4px;">
                <strong style="color: #4caf50;">‚úÖ Once connected:</strong>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li>The orange warning above will turn green</li>
                    <li>Run automated tests with the buttons below</li>
                    <li>Start monitoring to see real-time listener counts</li>
                    <li>Play the game in the iframe while watching metrics update!</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>üìä Live Memory Metrics</h2>
        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="memory-usage">0 MB</div>
                <div>Memory Usage</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="dom-nodes">0</div>
                <div>DOM Nodes</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="test-results">0/0</div>
                <div>Tests Passed</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="monitoring-status-small">OFF</div>
                <div>Memory Monitor</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>üß™ Unit Test Snapshot</h2>
        <p>Current unit test status and quick access to detailed testing:</p>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="unit-test-status">‚è≥</div>
                <div>Unit Tests Status</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="total-tests">0</div>
                <div>Total Tests</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="passing-tests">0</div>
                <div>Passing</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="failing-tests">0</div>
                <div>Failing</div>
            </div>
        </div>

        <div style="margin-top: 15px;">
            <button onclick="refreshUnitTests()">üîÑ Refresh Tests</button>
        </div>

        <div id="unit-test-details" style="margin-top: 10px; font-size: 0.9em; color: #ccc;">
            Click "Refresh Tests" to see current unit test status
        </div>

        <div style="margin-top: 15px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 5px; border-left: 3px solid #4fc3f7;">
            <div style="font-size: 0.9em; color: #4fc3f7; margin-bottom: 5px;">
                <strong>üí° Interactive Test Interface</strong>
            </div>
            <div style="font-size: 0.85em; color: #ccc; line-height: 1.4;">
                For complete interactive unit test results with visualization
                    and debugging, run <span style="margin: 3px 3px; padding:
                        3px; background: rgba(0, 0, 0, 0.3); font-family:
                        monospace; color: #4fc3f7">npm run test:ui</span> in
                    your terminal.
                This will open the Vitest UI in your browser with full test exploration capabilities.
            </div>
        </div>
    </div>

    <div class="container">
        <h2>üìà Memory Usage Trends</h2>
        <p>Real-time memory monitoring and pattern visualization:</p>

        <div style="margin: 15px 0;">
            <button onclick="toggleMonitoring()" id="monitor-btn">‚ñ∂Ô∏è Start Monitoring</button>
            <button onclick="clearMemoryHistory()">üóëÔ∏è Clear History</button>
            <button onclick="markEvent('user-action')">üìç Mark Event</button>
            <span style="margin-left: 15px; color: #888;">Monitoring: <span id="monitoring-status">OFF</span></span>
        </div>

        <canvas id="memory-chart" width="1000" height="300" style="background: #1a1a1a; border: 1px solid #444; border-radius: 4px; width: 100%; max-width: 100%;"></canvas>

        <div style="margin-top: 10px; font-size: 0.85em; color: #ccc;">
            <div>üìä Chart shows memory usage over time - look for stable trends, not sudden spikes</div>
            <div>üéØ Memory patterns are more valuable than pass/fail tests</div>
            <div>üîç Click "Mark Event" during game actions to correlate memory with gameplay</div>
        </div>
    </div>

    <div class="container">
        <h2>üéØ Event Listener Monitoring</h2>
        <p>Real-time tracking of event listeners to detect memory leaks:</p>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="current-listener-count">0</div>
                <div>Current Listeners</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="peak-listener-count">0</div>
                <div>Peak Listeners</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="listener-trend">STABLE</div>
                <div>Listener Trend</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="active-scene">N/A</div>
                <div>Active Scene</div>
            </div>
        </div>

        <canvas id="listener-chart" width="1000" height="200" style="background: #1a1a1a; border: 1px solid #444; border-radius: 4px; width: 100%; max-width: 100%; margin-top: 15px;"></canvas>

        <div style="margin-top: 10px; font-size: 0.85em; color: #ccc;">
            <div>üìä Chart shows event listener count over time - should remain stable</div>
            <div>üéØ Listener count should return to baseline after scene transitions</div>
            <div>üîç Growing listener count indicates a memory leak</div>
        </div>
    </div>

    <div class="container">
        <h2>üß™ Automated Event Cleanup Tests</h2>
        <p>Automated tests for scene transition cleanup:</p>

        <div style="margin-bottom: 15px;">
            <button onclick="runRapidTransitionTest()">üîÑ Test Rapid Transitions (20x)</button>
            <button onclick="runGameSettingsTest()">‚öôÔ∏è Test Game ‚Üî Settings (5x)</button>
            <button onclick="runManualListenerCount()">üìä Count Listeners Now</button>
        </div>

        <div id="test-status" style="margin: 15px 0; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 4px; min-height: 60px;">
            <div style="font-size: 0.9em; color: #888;">
                Click a test button to start automated cleanup validation
            </div>
        </div>

        <div style="margin-top: 10px; padding: 8px; background: rgba(76, 175, 80, 0.1); border-left: 3px solid #4caf50; border-radius: 3px;">
            <div style="font-size: 0.85em; color: #4caf50;">
                <strong>‚úÖ These tests integrate with your Phaser game</strong>
            </div>
            <div style="font-size: 0.8em; color: #ccc; margin-top: 3px;">
                Tests will perform real scene transitions and count actual event listeners using Phaser's listenerCount() API.
                Make sure your game is running before testing.
            </div>
        </div>
    </div>

    <div class="container">
        <h2>üß™ Quick Memory Tests</h2>
        <p>Simple validation tests for reference (less reliable than trend monitoring):</p>

        <button onclick="runEventBusTest()">üì° Test EventBus Memory Leaks</button>
        <button onclick="runSceneTest()">üéÆ Test Scene Transition Memory</button>
        <button onclick="clearLog()">üóëÔ∏è Clear Log</button>

        <div style="margin-top: 10px; padding: 8px; background: rgba(255, 152, 0, 0.1); border-left: 3px solid #ff9800; border-radius: 3px;">
            <div style="font-size: 0.85em; color: #ff9800;">
                <strong>‚ö†Ô∏è Focus on Trends, Not Individual Tests</strong>
            </div>
            <div style="font-size: 0.8em; color: #ccc; margin-top: 3px;">
                Memory testing is inherently non-deterministic. Use the chart above to observe patterns during actual gameplay rather than relying on these artificial tests.
            </div>
        </div>
    </div>

    <div class="container">
        <h2>üìù Validation Log</h2>
        <div class="log" id="log"></div>
    </div>

    <div class="container">
        <h2>üìà Expected Results</h2>
        <div class="success">
          <strong>‚úÖ Unit Tests:</strong> All unit tests should pass successfully <br>
          <strong>‚úÖ EventBus Cleanup:</strong> Event listeners should not accumulate over time <br>
          <strong>‚úÖ Scene Transitions:</strong> Memory should return to baseline after scene cleanup <br>
          <strong>üìà Memory Trends:</strong> Chart should show stable patterns during gameplay <br>
          <strong>üéØ Focus Areas:</strong> Look for memory leaks during extended play sessions <br>
        </div>
    </div>

    <script>
        let testResults = { passed: 0, total: 0 };
        let logMessages = [];

        // Memory monitoring variables
        let isMonitoring = false;
        let memoryHistory = [];
        let memoryChartInterval = null;
        let maxDataPoints = 100; // Show last 100 data points
        let markedEvents = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            logMessages.push(logEntry);

            const logElement = document.getElementById('log');
            logElement.innerHTML += logEntry + '<br/>\n';
            logElement.scrollTop = logElement.scrollHeight;

            console.log(logEntry);
        }

        function updateMetrics() {
            // Memory usage
            if (performance.memory) {
                const usedMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024 * 100) / 100;
                document.getElementById('memory-usage').textContent = `${usedMB} MB`;

                // Add to history if monitoring
                if (isMonitoring) {
                    addMemoryDataPoint(performance.memory.usedJSHeapSize);
                }
            }

            // DOM nodes
            const domNodes = document.querySelectorAll('*').length;
            document.getElementById('dom-nodes').textContent = domNodes;

            // Test results
            document.getElementById('test-results').textContent = `${testResults.passed}/${testResults.total}`;

            // Monitoring status
            const statusElement = document.getElementById('monitoring-status-small');
            if (statusElement) {
                statusElement.textContent = isMonitoring ? 'ON' : 'OFF';
                statusElement.style.color = isMonitoring ? '#4caf50' : '#f44336';
            }
        }

        function addMemoryDataPoint(memoryBytes) {
            const timestamp = Date.now();
            const memoryMB = memoryBytes / 1024 / 1024;

            memoryHistory.push({
                timestamp: timestamp,
                memory: memoryMB,
                type: 'normal'
            });

            // Keep only the last maxDataPoints
            if (memoryHistory.length > maxDataPoints) {
                memoryHistory = memoryHistory.slice(-maxDataPoints);
            }

            drawMemoryChart();
        }

        function drawMemoryChart() {
            const canvas = document.getElementById('memory-chart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (memoryHistory.length < 2) return;

            // Calculate min and max for scaling
            const memories = memoryHistory.map(d => d.memory);
            const minMemory = Math.min(...memories);
            const maxMemory = Math.max(...memories);
            const memoryRange = maxMemory - minMemory || 1;

            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();

                // Add memory value labels
                const value = maxMemory - (memoryRange / 5) * i;
                ctx.fillStyle = '#888';
                ctx.font = '10px monospace';
                ctx.fillText(`${value.toFixed(1)} MB`, 5, y - 2);
            }

            // Draw marked events
            ctx.strokeStyle = '#ff9800';
            ctx.fillStyle = '#ff9800';
            markedEvents.forEach(event => {
                const eventIndex = memoryHistory.findIndex(d => d.timestamp >= event.timestamp);
                if (eventIndex >= 0 && eventIndex < memoryHistory.length) {
                    const x = (eventIndex / (maxDataPoints - 1)) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();

                    // Add event label
                    ctx.save();
                    ctx.translate(x + 5, 20);
                    ctx.rotate(-Math.PI / 4);
                    ctx.font = '10px sans-serif';
                    ctx.fillText(event.label, 0, 0);
                    ctx.restore();
                }
            });

            // Draw memory line
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 2;
            ctx.beginPath();

            memoryHistory.forEach((dataPoint, index) => {
                const x = (index / (maxDataPoints - 1)) * width;
                const y = height - ((dataPoint.memory - minMemory) / memoryRange) * height;

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Draw data points
            ctx.fillStyle = '#4caf50';
            memoryHistory.forEach((dataPoint, index) => {
                const x = (index / (maxDataPoints - 1)) * width;
                const y = height - ((dataPoint.memory - minMemory) / memoryRange) * height;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw baseline (average of first 5 points)
            if (memoryHistory.length >= 10) {
                const baseline = memoryHistory.slice(0, 5).reduce((sum, d) => sum + d.memory, 0) / 5;
                const baselineY = height - ((baseline - minMemory) / memoryRange) * height;

                ctx.strokeStyle = '#2196f3';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, baselineY);
                ctx.lineTo(width, baselineY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Baseline label
                ctx.fillStyle = '#2196f3';
                ctx.font = '10px sans-serif';
                ctx.fillText('Baseline', width - 40, baselineY - 5);
            }
        }

        function toggleMonitoring() {
            if (isMonitoring) {
                stopMonitoring();
            } else {
                startMonitoring();
            }
        }

        function startMonitoring() {
            if (isMonitoring) return;

            isMonitoring = true;
            document.getElementById('monitor-btn').textContent = '‚è∏Ô∏è Stop Monitoring';
            document.getElementById('monitoring-status').textContent = 'ON';
            document.getElementById('monitoring-status').style.color = '#4caf50';

            log('üìä Memory monitoring started - watch for patterns during gameplay', 'info');

            // Start collecting data every 500ms
            memoryChartInterval = setInterval(() => {
                if (performance.memory) {
                    addMemoryDataPoint(performance.memory.usedJSHeapSize);
                }
            }, 500);
        }

        function stopMonitoring() {
            if (!isMonitoring) return;

            isMonitoring = false;
            document.getElementById('monitor-btn').textContent = '‚ñ∂Ô∏è Start Monitoring';
            document.getElementById('monitoring-status').textContent = 'OFF';
            document.getElementById('monitoring-status').style.color = '#888';

            if (memoryChartInterval) {
                clearInterval(memoryChartInterval);
                memoryChartInterval = null;
            }

            log('üìä Memory monitoring stopped', 'info');

            // Analyze trends
            analyzeMemoryTrends();
        }

        function clearMemoryHistory() {
            memoryHistory = [];
            markedEvents = [];
            drawMemoryChart();
            log('üìä Memory history cleared', 'info');
        }

        function markEvent(type) {
            if (!isMonitoring) {
                log('‚ö†Ô∏è Start monitoring first to mark events', 'warning');
                return;
            }

            const event = {
                timestamp: Date.now(),
                label: prompt('Enter event label:') || type
            };

            markedEvents.push(event);
            drawMemoryChart();
            log(`üìç Event marked: ${event.label}`, 'info');
        }

        function analyzeMemoryTrends() {
            if (memoryHistory.length < 10) {
                log('üìä Insufficient data for trend analysis', 'warning');
                return;
            }

            const memories = memoryHistory.map(d => d.memory);
            const firstQuarter = memories.slice(0, Math.floor(memories.length / 4));
            const lastQuarter = memories.slice(-Math.floor(memories.length / 4));

            const firstAvg = firstQuarter.reduce((a, b) => a + b, 0) / firstQuarter.length;
            const lastAvg = lastQuarter.reduce((a, b) => a + b, 0) / lastQuarter.length;

            const trend = lastAvg - firstAvg;
            const trendPercent = (trend / firstAvg) * 100;

            if (Math.abs(trendPercent) < 2) {
                log(`üìä Memory analysis: STABLE (${trendPercent > 0 ? '+' : ''}${trendPercent.toFixed(1)}% change)`, 'success');
            } else if (trendPercent > 0) {
                log(`üìä Memory analysis: INCREASING (+${trendPercent.toFixed(1)}% change) - monitor for leaks`, 'warning');
            } else {
                log(`üìä Memory analysis: DECREASING (${trendPercent.toFixed(1)}% change) - good memory management`, 'success');
            }

            const maxMemory = Math.max(...memories);
            const minMemory = Math.min(...memories);
            const volatility = ((maxMemory - minMemory) / minMemory) * 100;

            if (volatility < 10) {
                log(`üìä Memory volatility: LOW (${volatility.toFixed(1)}%) - consistent usage pattern`, 'success');
            } else {
                log(`üìä Memory volatility: HIGH (${volatility.toFixed(1)}%) - may indicate allocation issues`, 'warning');
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            logMessages = [];
            log('Log cleared');
        }

        // Mock EventBusManager for demonstration
        class MockEventBusManager {
            static listeners = new Map();

            static on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push(callback);
            }

            static removeListener(event, callback) {
                const eventListeners = this.listeners.get(event);
                if (eventListeners) {
                    const index = eventListeners.indexOf(callback);
                    if (index > -1) {
                        eventListeners.splice(index, 1);
                    }
                    if (eventListeners.length === 0) {
                        this.listeners.delete(event);
                    }
                }
            }

            static off(event) {
                this.listeners.delete(event);
            }

            static cleanup() {
                this.listeners.clear();
            }

            static getListenerCount() {
                return this.listeners.size;
            }

            static getActiveEvents() {
                return Array.from(this.listeners.keys());
            }
        }

        async function runEventBusTest() {
            testResults.total++;
            log('üì° Testing EventBus Memory Leak Prevention...', 'info');

            const initialCount = MockEventBusManager.getListenerCount();
            log(`   Initial listener count: ${initialCount}`);

            // Add many listeners
            const callbacks = [];
            for (let i = 0; i < 100; i++) {
                const callback = () => `Callback ${i}`;
                MockEventBusManager.on(`test-event-${i}`, callback);
                callbacks.push({ event: `test-event-${i}`, callback });
            }

            log(`   Added 100 listeners, count: ${MockEventBusManager.getListenerCount()}`);

            // Remove all listeners
            callbacks.forEach(({ event, callback }) => {
                MockEventBusManager.removeListener(event, callback);
            });

            const finalCount = MockEventBusManager.getListenerCount();
            log(`   After cleanup, count: ${finalCount}`);

            const passed = finalCount === initialCount;

            if (passed) {
                testResults.passed++;
                log('   ‚úÖ EventBus memory leak prevention: PASSED', 'success');
            } else {
                log(`   ‚ùå EventBus memory leak prevention: FAILED (${finalCount - initialCount} listeners remaining)`, 'error');
            }

            updateMetrics();
        }

        async function runSceneTest() {
            testResults.total++;
            log('üéÆ Testing Scene Transition Memory...', 'info');

            const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
            log(`   Initial memory: ${formatBytes(initialMemory)}`);

            // Simulate scene creation
            const sceneObjects = [];
            for (let i = 0; i < 50; i++) {
                sceneObjects.push({
                    id: i,
                    data: new Array(1000).fill(Math.random()),
                    cleanup: function() {
                        this.data = null;
                    }
                });
            }

            const peakMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
            log(`   Peak memory during scene: ${formatBytes(peakMemory)}`);

            // Simulate scene cleanup
            sceneObjects.forEach(obj => obj.cleanup());
            sceneObjects.length = 0;

            // Force garbage collection if available
            if (window.gc) {
                window.gc();
            }

            await new Promise(resolve => setTimeout(resolve, 100));

            const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
            log(`   Final memory after cleanup: ${formatBytes(finalMemory)}`);

            const memoryGrowth = finalMemory - initialMemory;
            const passed = memoryGrowth < 10000000; // Less than 10MB growth

            if (passed) {
                testResults.passed++;
                log(`   ‚úÖ Scene transition memory: PASSED (growth: ${formatBytes(memoryGrowth)})`, 'success');
            } else {
                log(`   ‚ùå Scene transition memory: FAILED (growth: ${formatBytes(memoryGrowth)})`, 'error');
            }

            updateMetrics();
        }

        // Removed unreliable object lifecycle test - use memory monitoring chart instead

        async function runQuickValidation() {
            log('üöÄ Running Quick Memory Validation Suite...', 'info');
            log('=====================================', 'info');

            // Reset test results
            testResults = { passed: 0, total: 0 };

            await runEventBusTest();
            await new Promise(resolve => setTimeout(resolve, 500));

            await runSceneTest();
            await new Promise(resolve => setTimeout(resolve, 500));

            log('=====================================', 'info');
            log('üìä QUICK VALIDATION RESULTS', 'info');
            log(`   Tests passed: ${testResults.passed}/${testResults.total}`,
                testResults.passed === testResults.total ? 'success' : 'error');

            if (testResults.passed === testResults.total) {
                log('üéâ Basic tests passed! For comprehensive monitoring, use the memory chart above.', 'success');
                log('', 'success');
                log('‚úÖ EventBus memory leak prevention: WORKING', 'success');
                log('‚úÖ Scene shutdown methods: WORKING', 'success');
                log('üìà Real-time memory monitoring: READY - Click "Start Monitoring" above', 'success');
            } else {
                log('‚ö†Ô∏è  Some tests failed. Please review the implementation.', 'warning');
            }

            log('=====================================', 'info');
            log('üí° Tip: Use the memory chart to observe patterns during actual gameplay', 'info');
            updateMetrics();
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Unit Test Functions
        
        async function refreshUnitTests() {
            log('üîÑ Refreshing unit test status...', 'info');

            // Update UI to show loading
            document.getElementById('unit-test-status').textContent = '‚è≥';
            document.getElementById('unit-test-details').textContent = 'Running unit tests...';

            try {
                // Fetch real test results from test status server
                const response = await fetch('http://localhost:3001/test-status');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const results = await response.json();

                // Update UI with real results
                document.getElementById('total-tests').textContent = results.total;
                document.getElementById('passing-tests').textContent = results.passed;
                document.getElementById('failing-tests').textContent = results.failed;

                const status = results.success && results.failed === 0 ? '‚úÖ' : '‚ùå';
                document.getElementById('unit-test-status').textContent = status;

                const time = new Date(results.timestamp).toLocaleTimeString();
                const details = `Last updated: ${time} | ${results.passed}/${results.total} passing`;

                if (results.error) {
                    document.getElementById('unit-test-details').textContent = `Warning: ${results.error}`;
                } else {
                    document.getElementById('unit-test-details').textContent = details;
                }

                log(`‚úÖ Unit test status updated: ${results.passed}/${results.total} tests passing`, 'success');

            } catch (error) {
                log(`‚ùå Failed to refresh unit tests: ${error.message}`, 'error');
                document.getElementById('unit-test-status').textContent = '‚ö†Ô∏è';
                document.getElementById('unit-test-details').textContent = 'Test status server unavailable - start with: node scripts/test-status-server.js';

                // Fallback to known good values
                document.getElementById('total-tests').textContent = '456';
                document.getElementById('passing-tests').textContent = '456';
                document.getElementById('failing-tests').textContent = '0';
            }
        }

        // Update metrics periodically
        setInterval(updateMetrics, 2000);

        // Initial setup
        log('üöÄ Memory Monitoring Dashboard Loaded', 'success');
        log('üìä Real-time memory chart is ready - click "Start Monitoring" to begin', 'info');
        log('üß™ Quick validation tests are available for basic checks', 'info');
        log('üî¨ Use "Open Vitest UI" for detailed unit test exploration', 'info');
        log('üîÑ Click "Refresh Tests" to see current unit test status', 'info');
        log('', 'info');

        // Initial metrics update
        updateMetrics();

        // Auto-refresh unit tests on page load after a short delay
        setTimeout(() => {
            log('üîÑ Auto-refreshing unit test status...', 'info');
            refreshUnitTests();
        }, 2000);

        // ============================================================================
        // EVENT LISTENER MONITORING
        // ============================================================================

        let listenerHistory = [];
        let peakListenerCount = 0;
        let listenerMonitoringInterval = null;

        /**
         * Toggle game view visibility
         */
        function toggleGameView() {
            const container = document.getElementById('game-iframe-container');
            const btn = document.getElementById('toggle-game-btn');

            if (container.style.display === 'none') {
                container.style.display = 'block';
                btn.textContent = 'Hide Game';
                log('üéÆ Game view shown - waiting for game to load...', 'info');

                // Wait for iframe to load, then check for game
                setTimeout(() => {
                    checkGameConnection();
                }, 2000);
            } else {
                container.style.display = 'none';
                btn.textContent = 'Show Game';
            }
        }

        /**
         * Get reference to Phaser game instance
         * This checks the iframe first, then falls back to other methods
         */
        function getPhaserGame() {
            // FIRST: Try to get from iframe (preferred method)
            const gameFrame = document.getElementById('game-frame');
            if (gameFrame && gameFrame.contentWindow) {
                try {
                    const iframeWindow = gameFrame.contentWindow;

                    // Try to get gameInstance from the iframe
                    const iframeGame = iframeWindow.gameInstance || iframeWindow.game;

                    // Verify it's actually a Phaser game instance
                    // Just check if it has a scene property with scenes array
                    if (iframeGame && iframeGame.scene && iframeGame.scene.scenes) {
                        return iframeGame;
                    }
                } catch (error) {
                    // Cross-origin errors - can't access iframe
                    console.warn('[Live Testing] Cannot access iframe:', error.message);
                }
            }

            // Try to get game from window.game (user manually exposed in same window)
            if (window.game && window.game.scene && window.game.scene.scenes) {
                return window.game;
            }

            // Check for window.gameInstance (if game loaded in same window)
            if (window.gameInstance && window.gameInstance.scene && window.gameInstance.scene.scenes) {
                return window.gameInstance;
            }

            return null;
        }

        /**
         * Count all event listeners in a Phaser scene
         */
        function countSceneListeners(scene) {
            if (!scene) return 0;

            let total = 0;

            try {
                // Count listeners on scene events
                if (scene.events && scene.events.eventNames) {
                    const sceneEvents = scene.events.eventNames();
                    total += sceneEvents.reduce((sum, eventName) => {
                        return sum + (scene.events.listenerCount(eventName) || 0);
                    }, 0);
                }

                // Count listeners on input events
                if (scene.input && scene.input.events && scene.input.events.eventNames) {
                    const inputEvents = scene.input.events.eventNames();
                    total += inputEvents.reduce((sum, eventName) => {
                        return sum + (scene.input.events.listenerCount(eventName) || 0);
                    }, 0);
                }

                // Count listeners on game objects (interactive elements)
                if (scene.children && scene.children.list) {
                    scene.children.list.forEach(child => {
                        // Check for pointer events on interactive objects
                        ['pointerdown', 'pointerover', 'pointerout', 'pointerup'].forEach(eventType => {
                            if (child.listenerCount) {
                                total += child.listenerCount(eventType) || 0;
                            }
                        });
                    });
                }
            } catch (error) {
                console.warn('Error counting scene listeners:', error);
            }

            return total;
        }

        /**
         * Check if the game is fully ready for testing
         * Returns true only if game is initialized with all scene manager methods
         */
        function isGameReady() {
            const game = getPhaserGame();
            if (!game) return false;
            if (!game.scene) return false;

            // Check that SceneManager has all required methods
            if (typeof game.scene.start !== 'function') return false;
            if (typeof game.scene.getScene !== 'function') return false;

            // Check that at least one scene exists and is active
            const scenes = game.scene.scenes || [];
            if (scenes.length === 0) return false;

            const hasActiveScene = scenes.some(s => s.scene && s.scene.isActive());
            if (!hasActiveScene) return false;

            return true;
        }

        /**
         * Wait for the game to be fully ready
         * Polls every 100ms for up to 10 seconds
         */
        async function waitForGameReady(timeoutMs = 10000) {
            const startTime = Date.now();

            while (Date.now() - startTime < timeoutMs) {
                if (isGameReady()) {
                    return true;
                }
                await wait(100);
            }

            return false;
        }

        /**
         * Get the currently active scene
         */
        function getActiveScene() {
            const game = getPhaserGame();
            if (!game || !game.scene) return null;

            // Get all scenes
            const scenes = game.scene.scenes || [];

            // Find the active scene
            const activeScene = scenes.find(s => s.scene && s.scene.isActive());

            return activeScene || null;
        }

        /**
         * Update listener count display
         */
        function updateListenerCount() {
            const scene = getActiveScene();

            if (!scene) {
                document.getElementById('current-listener-count').textContent = 'N/A';
                document.getElementById('active-scene').textContent = 'No game';
                return;
            }

            const count = countSceneListeners(scene);
            const sceneName = scene.scene.key || 'Unknown';

            // Update display
            document.getElementById('current-listener-count').textContent = count;
            document.getElementById('active-scene').textContent = sceneName;

            // Track peak
            if (count > peakListenerCount) {
                peakListenerCount = count;
                document.getElementById('peak-listener-count').textContent = peakListenerCount;
            }

            // Add to history if monitoring
            if (isMonitoring) {
                addListenerDataPoint(count, sceneName);
            }

            return count;
        }

        /**
         * Add listener count data point to history
         */
        function addListenerDataPoint(count, sceneName) {
            const timestamp = Date.now();

            listenerHistory.push({
                timestamp: timestamp,
                count: count,
                scene: sceneName
            });

            // Keep only the last 100 points
            if (listenerHistory.length > 100) {
                listenerHistory = listenerHistory.slice(-100);
            }

            drawListenerChart();
            updateListenerTrend();
        }

        /**
         * Draw listener count chart
         */
        function drawListenerChart() {
            const canvas = document.getElementById('listener-chart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (listenerHistory.length < 2) return;

            // Calculate min and max for scaling
            const counts = listenerHistory.map(d => d.count);
            const minCount = Math.min(...counts);
            const maxCount = Math.max(...counts);
            const countRange = maxCount - minCount || 1;

            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();

                // Add count value labels
                const value = maxCount - (countRange / 5) * i;
                ctx.fillStyle = '#888';
                ctx.font = '10px monospace';
                ctx.fillText(Math.round(value), 5, y - 2);
            }

            // Draw listener count line
            ctx.strokeStyle = '#2196f3';
            ctx.lineWidth = 2;
            ctx.beginPath();

            listenerHistory.forEach((dataPoint, index) => {
                const x = (index / (100 - 1)) * width;
                const y = height - ((dataPoint.count - minCount) / countRange) * height;

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Draw data points
            ctx.fillStyle = '#2196f3';
            listenerHistory.forEach((dataPoint, index) => {
                const x = (index / (100 - 1)) * width;
                const y = height - ((dataPoint.count - minCount) / countRange) * height;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw baseline (first value)
            if (listenerHistory.length >= 5) {
                const baseline = listenerHistory[0].count;
                const baselineY = height - ((baseline - minCount) / countRange) * height;

                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, baselineY);
                ctx.lineTo(width, baselineY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Baseline label
                ctx.fillStyle = '#4caf50';
                ctx.font = '10px sans-serif';
                ctx.fillText('Baseline', width - 50, baselineY - 5);
            }
        }

        /**
         * Update listener trend indicator
         */
        function updateListenerTrend() {
            if (listenerHistory.length < 10) {
                document.getElementById('listener-trend').textContent = 'MONITORING';
                return;
            }

            const counts = listenerHistory.map(d => d.count);
            const firstQuarter = counts.slice(0, Math.floor(counts.length / 4));
            const lastQuarter = counts.slice(-Math.floor(counts.length / 4));

            const firstAvg = firstQuarter.reduce((a, b) => a + b, 0) / firstQuarter.length;
            const lastAvg = lastQuarter.reduce((a, b) => a + b, 0) / lastQuarter.length;

            const trend = lastAvg - firstAvg;
            const trendPercent = (trend / firstAvg) * 100;

            const trendElement = document.getElementById('listener-trend');

            if (Math.abs(trendPercent) < 5) {
                trendElement.textContent = 'STABLE';
                trendElement.style.color = '#4caf50';
            } else if (trendPercent > 0) {
                trendElement.textContent = `GROWING (+${Math.round(trendPercent)}%)`;
                trendElement.style.color = '#f44336';
            } else {
                trendElement.textContent = `DECREASING (${Math.round(trendPercent)}%)`;
                trendElement.style.color = '#ff9800';
            }
        }

        // ============================================================================
        // AUTOMATED TESTS
        // ============================================================================

        /**
         * Utility function to wait for a duration
         */
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Update test status display
         */
        function updateTestStatus(message, type = 'info') {
            const statusDiv = document.getElementById('test-status');
            let color = '#888';

            if (type === 'success') color = '#4caf50';
            if (type === 'error') color = '#f44336';
            if (type === 'warning') color = '#ff9800';

            statusDiv.innerHTML = `<div style="font-size: 0.9em; color: ${color};">${message}</div>`;
        }

        /**
         * Test: Rapid Scene Transitions (20x)
         * Tests that listener counts remain stable during rapid scene switching
         */
        async function runRapidTransitionTest() {
            log('üîÑ Starting Rapid Transition Test (20 cycles)...', 'info');
            updateTestStatus('‚è≥ Waiting for game to be ready...', 'info');

            // Wait for game to be fully initialized
            const ready = await waitForGameReady();
            if (!ready) {
                const error = '‚ùå Timeout waiting for game to initialize. Make sure the game is loaded and a scene is active.';
                log(error, 'error');
                updateTestStatus(error, 'error');
                return;
            }

            log('‚úÖ Game is ready, starting test...', 'success');
            updateTestStatus('üîÑ Running rapid transition test... (0/20)', 'info');

            const game = getPhaserGame();

            const results = {
                cycles: 20,
                listenerCounts: [],
                errors: [],
                pass: false
            };

            try {
                for (let i = 0; i < 20; i++) {
                    updateTestStatus(`üîÑ Running rapid transition test... (${i + 1}/20)`, 'info');

                    // Start Game scene
                    game.scene.start('Game');
                    await wait(150);

                    // Count listeners
                    const gameScene = game.scene.getScene('Game');
                    if (gameScene && gameScene.scene.isActive()) {
                        const count = countSceneListeners(gameScene);
                        results.listenerCounts.push(count);
                        log(`   Cycle ${i + 1}: Game scene has ${count} listeners`);
                    } else {
                        log(`   Cycle ${i + 1}: Game scene not active yet`, 'warning');
                    }

                    // Return to MainMenu
                    game.scene.start('MainMenu');
                    await wait(150);
                }

                // Analyze results
                const maxCount = Math.max(...results.listenerCounts);
                const minCount = Math.min(...results.listenerCounts);
                const avgCount = results.listenerCounts.reduce((a, b) => a + b, 0) / results.listenerCounts.length;

                // Listeners should be stable (not growing)
                results.pass = (maxCount === minCount) || (maxCount - minCount <= 2);

                const resultMessage = results.pass
                    ? `‚úÖ PASSED: Listener counts stable (${minCount}-${maxCount}, avg ${avgCount.toFixed(1)})`
                    : `‚ùå FAILED: Listener counts growing (${minCount}-${maxCount}, avg ${avgCount.toFixed(1)})`;

                log(resultMessage, results.pass ? 'success' : 'error');
                updateTestStatus(resultMessage, results.pass ? 'success' : 'error');

            } catch (error) {
                const errorMsg = `‚ùå Test failed with error: ${error.message}`;
                log(errorMsg, 'error');
                updateTestStatus(errorMsg, 'error');
                results.errors.push(error.message);
            }

            log('üîÑ Rapid Transition Test complete', 'info');
            return results;
        }

        /**
         * Test: Game ‚Üî Settings Transitions (5x)
         * Tests that game state is preserved and listeners are stable
         */
        async function runGameSettingsTest() {
            log('‚öôÔ∏è Starting Game ‚Üî Settings Transition Test (5 cycles)...', 'info');
            updateTestStatus('‚è≥ Waiting for game to be ready...', 'info');

            // Wait for game to be fully initialized
            const ready = await waitForGameReady();
            if (!ready) {
                const error = '‚ùå Timeout waiting for game to initialize. Make sure the game is loaded and a scene is active.';
                log(error, 'error');
                updateTestStatus(error, 'error');
                return;
            }

            log('‚úÖ Game is ready, starting test...', 'success');
            updateTestStatus('‚öôÔ∏è Running Game ‚Üî Settings test... (0/5)', 'info');

            const game = getPhaserGame();

            const results = {
                cycles: 5,
                listenerCounts: [],
                statePreserved: true,
                cleanupVerified: true,
                pass: false
            };

            try {
                // Start Game scene
                game.scene.start('Game');
                await wait(300);

                const gameScene = game.scene.getScene('Game');
                if (!gameScene) {
                    throw new Error('Game scene not found');
                }

                const initialCount = countSceneListeners(gameScene);
                log(`   Initial Game scene listener count: ${initialCount}`);

                for (let i = 0; i < 5; i++) {
                    updateTestStatus(`‚öôÔ∏è Running Game ‚Üî Settings test... (${i + 1}/5)`, 'info');

                    const beforeCount = countSceneListeners(gameScene);
                    results.listenerCounts.push(beforeCount);

                    // Transition to Settings
                    game.scene.start('Settings');
                    await wait(200);

                    log(`   Cycle ${i + 1}: Transitioned to Settings`);

                    // Transition back to Game
                    game.scene.start('Game');
                    await wait(200);

                    const afterCount = countSceneListeners(game.scene.getScene('Game'));
                    log(`   Cycle ${i + 1}: Back to Game, listener count: ${afterCount}`);

                    // Verify listeners didn't accumulate
                    if (Math.abs(afterCount - initialCount) > 2) {
                        results.cleanupVerified = false;
                        log(`   ‚ö†Ô∏è Cycle ${i + 1}: Listener count changed from ${initialCount} to ${afterCount}`, 'warning');
                    }
                }

                // Analyze results
                const maxCount = Math.max(...results.listenerCounts);
                const minCount = Math.min(...results.listenerCounts);

                results.pass = results.cleanupVerified && (maxCount - minCount <= 2);

                const resultMessage = results.pass
                    ? `‚úÖ PASSED: State preserved, listeners stable (${minCount}-${maxCount})`
                    : `‚ùå FAILED: Listener accumulation detected (${minCount} ‚Üí ${maxCount})`;

                log(resultMessage, results.pass ? 'success' : 'error');
                updateTestStatus(resultMessage, results.pass ? 'success' : 'error');

            } catch (error) {
                const errorMsg = `‚ùå Test failed with error: ${error.message}`;
                log(errorMsg, 'error');
                updateTestStatus(errorMsg, 'error');
            }

            log('‚öôÔ∏è Game ‚Üî Settings Test complete', 'info');
            return results;
        }

        /**
         * Diagnostic - Show what game object we're getting
         */
        function diagnoseGameDetection() {
            log('üîç Diagnosing game detection...', 'info');

            const game = getPhaserGame();

            if (!game) {
                log('   ‚ùå No game detected', 'error');
                log('   Make sure you clicked "Show Game" button', 'info');
                return;
            }

            log('   ‚úÖ Game object found!', 'success');
            log(`   - Type: ${typeof game}`, 'info');
            log(`   - Constructor: ${game.constructor?.name}`, 'info');
            log(`   - Has scene: ${!!game.scene}`, 'info');
            log(`   - scene.start exists: ${typeof game.scene?.start}`, 'info');
            log(`   - scene.getScene exists: ${typeof game.scene?.getScene}`, 'info');
            log(`   - scene.scenes array: ${game.scene?.scenes?.length || 0} scenes`, 'info');

            // Check if game is ready
            const ready = isGameReady();
            if (ready) {
                log('   ‚úÖ Game is READY for testing!', 'success');
            } else {
                log('   ‚ö†Ô∏è Game is NOT ready for testing yet', 'warning');
                log('      Waiting for SceneManager to fully initialize...', 'info');
            }

            if (game.scene?.scenes) {
                log('   - Scene list:', 'info');
                game.scene.scenes.forEach(s => {
                    const isActive = s.scene && s.scene.isActive();
                    log(`     ‚Ä¢ ${s.scene.key} (active: ${isActive})`, isActive ? 'success' : 'info');
                });
            }

            return game;
        }

        /**
         * Manually count and display listeners for current scene
         */
        function runManualListenerCount() {
            log('üìä Counting event listeners in current scene...', 'info');

            const scene = getActiveScene();
            if (!scene) {
                const error = '‚ùå No active scene found';
                log(error, 'error');
                updateTestStatus(error, 'error');

                // Run diagnostic
                log('   Running diagnostic...', 'info');
                diagnoseGameDetection();
                return;
            }

            const sceneName = scene.scene.key || 'Unknown';
            const count = countSceneListeners(scene);

            log(`   Scene: ${sceneName}`, 'info');
            log(`   Total event listeners: ${count}`, 'info');

            // Break down by type
            let sceneEventCount = 0;
            let inputEventCount = 0;
            let gameObjectCount = 0;

            if (scene.events && scene.events.eventNames) {
                const sceneEvents = scene.events.eventNames();
                sceneEventCount = sceneEvents.reduce((sum, eventName) => {
                    return sum + (scene.events.listenerCount(eventName) || 0);
                }, 0);
            }

            if (scene.input && scene.input.events && scene.input.events.eventNames) {
                const inputEvents = scene.input.events.eventNames();
                inputEventCount = inputEvents.reduce((sum, eventName) => {
                    return sum + (scene.input.events.listenerCount(eventName) || 0);
                }, 0);
            }

            if (scene.children && scene.children.list) {
                scene.children.list.forEach(child => {
                    ['pointerdown', 'pointerover', 'pointerout', 'pointerup'].forEach(eventType => {
                        if (child.listenerCount) {
                            gameObjectCount += child.listenerCount(eventType) || 0;
                        }
                    });
                });
            }

            log(`   - Scene events: ${sceneEventCount}`, 'info');
            log(`   - Input events: ${inputEventCount}`, 'info');
            log(`   - GameObject events: ${gameObjectCount}`, 'info');

            updateTestStatus(`üìä ${sceneName}: ${count} total listeners (Scene: ${sceneEventCount}, Input: ${inputEventCount}, GameObjects: ${gameObjectCount})`, 'success');

            return { scene: sceneName, total: count, sceneEvents: sceneEventCount, inputEvents: inputEventCount, gameObjects: gameObjectCount };
        }

        // Start listener monitoring when memory monitoring starts
        const originalStartMonitoring = startMonitoring;
        startMonitoring = function() {
            originalStartMonitoring();

            // Also start listener monitoring
            if (!listenerMonitoringInterval) {
                listenerMonitoringInterval = setInterval(updateListenerCount, 500);
                log('üìä Listener monitoring started', 'info');
            }
        };

        const originalStopMonitoring = stopMonitoring;
        stopMonitoring = function() {
            originalStopMonitoring();

            // Also stop listener monitoring
            if (listenerMonitoringInterval) {
                clearInterval(listenerMonitoringInterval);
                listenerMonitoringInterval = null;
                log('üìä Listener monitoring stopped', 'info');
            }
        };

        // ============================================================================
        // CONNECTION STATUS MONITORING
        // ============================================================================

        /**
         * Check if game is connected and update status indicator
         */
        function checkGameConnection() {
            const statusDiv = document.getElementById('connection-status');

            if (isGameReady()) {
                // Game is fully ready!
                const game = getPhaserGame();
                statusDiv.style.background = 'rgba(76, 175, 80, 0.2)';
                statusDiv.style.borderColor = '#4caf50';
                statusDiv.innerHTML = `
                    <div style="font-weight: bold; color: #4caf50;">‚úÖ Game connected!</div>
                    <div style="font-size: 0.85em; margin-top: 5px;">
                        Ready to run tests and monitoring. Game has ${game.scene.scenes.length} scenes loaded.
                    </div>
                `;
                return true;
            } else {
                // Game not connected
                statusDiv.style.background = 'rgba(255, 152, 0, 0.2)';
                statusDiv.style.borderColor = '#ff9800';
                statusDiv.innerHTML = `
                    <div style="font-weight: bold; color: #ff9800;">‚ö†Ô∏è Game not detected</div>
                    <div style="font-size: 0.85em; margin-top: 5px;">
                        Follow the setup instructions below to connect to your game.
                    </div>
                `;
                return false;
            }
        }

        // Check connection status every 2 seconds
        setInterval(checkGameConnection, 2000);

        // Check immediately on load
        setTimeout(checkGameConnection, 1000);

        // Update listener count periodically (independent of memory monitoring)
        setInterval(() => {
            if (!isMonitoring) {
                updateListenerCount();
            }
        }, 2000);

        // Expose functions to global scope for debugging
        window.runEventBusTest = runEventBusTest;
        window.runSceneTest = runSceneTest;
        window.runQuickValidation = runQuickValidation;
        window.clearLog = clearLog;
        window.refreshUnitTests = refreshUnitTests;
        window.toggleMonitoring = toggleMonitoring;
        window.startMonitoring = startMonitoring;
        window.stopMonitoring = stopMonitoring;
        window.clearMemoryHistory = clearMemoryHistory;
        window.markEvent = markEvent;
        window.runRapidTransitionTest = runRapidTransitionTest;
        window.runGameSettingsTest = runGameSettingsTest;
        window.runManualListenerCount = runManualListenerCount;
        window.getPhaserGame = getPhaserGame;
        window.isGameReady = isGameReady;
        window.waitForGameReady = waitForGameReady;
        window.countSceneListeners = countSceneListeners;
        window.toggleGameView = toggleGameView;
        window.checkGameConnection = checkGameConnection;
        window.diagnoseGameDetection = diagnoseGameDetection;
    </script>
</body>
</html>